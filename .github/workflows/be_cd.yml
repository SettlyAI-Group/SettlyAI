name: BE_CD_Optimized

on:
  push:
    branches: [ main ]
    paths: [ 'backend/**' ]

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ap-southeast-2

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Find EC2 instance
        id: ec2
        run: |
          set -euo pipefail
          echo "Looking for EC2 tagged Name=${{ secrets.AWS_EC2_NAME }}..."
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${{ secrets.AWS_EC2_NAME }}" "Name=instance-state-name,Values=running" \
            --region $AWS_REGION \
            --query "Reservations[].Instances[0].InstanceId" \
            --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            echo "❌ No running instance found by that Name tag."
            exit 1
          fi
          echo "Found EC2 instance ID: $INSTANCE_ID"
          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_ENV

      - name: Wait for SSM registration
        run: |
          set -euo pipefail
          echo "Waiting for EC2 to register with SSM..."
          for i in {1..12}; do
            INSTANCE_INFO=$(aws ssm describe-instance-information \
              --region $AWS_REGION \
              --query "InstanceInformationList[?InstanceId=='$INSTANCE_ID']" \
              --output json)
            
            if [ "$(echo "$INSTANCE_INFO" | jq length)" -gt 0 ]; then
              PING_STATUS=$(echo "$INSTANCE_INFO" | jq -r '.[0].PingStatus // "Unknown"')
              echo "✅ EC2 instance registered with SSM! Status: $PING_STATUS"
              if [ "$PING_STATUS" = "Online" ]; then
                exit 0
              fi
            fi
            echo "⏳ Not yet online... retry in 10 seconds (attempt $i/12)"
            sleep 10
          done
          echo "❌ EC2 instance did not come online in SSM within 2 minutes."
          exit 1

      - name: Build optimized deploy script
        id: build-script
        env:
          ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
          AWS_REGION: ${{ env.AWS_REGION }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        run: |
          set -euo pipefail
          cat > /tmp/deploy-backend.sh << 'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          export DEBIAN_FRONTEND=noninteractive
          
          exec > >(tee -a /tmp/deploy.log)
          exec 2>&1
          echo "=== Deployment started at $(date) ==="
          
          # Kill any hanging processes first
          pkill -f "docker pull" || true
          pkill -f "dotnet ef" || true
          pkill -f "dotnet run" || true
          sleep 2
          
          echo "=== Install Docker if needed ==="
          if ! command -v docker >/dev/null 2>&1; then
            if [ -f /etc/debian_version ]; then
              apt-get update -y
              apt-get install -y docker.io curl
            elif [ -f /etc/amazon-linux-release ]; then
              yum update -y
              yum install -y docker curl
            fi
            systemctl enable --now docker
          fi
          
          # Ensure docker is running
          systemctl start docker || service docker start
          sleep 3
          
          echo "=== Setup ECR credentials ==="
          ECR_REGISTRY="__ECR_REGISTRY__"
          AWS_REGION="__AWS_REGION__"
          ECR_HOST="$(echo "$ECR_REGISTRY" | awk -F/ '{print $1}')"
          
          # Use AWS CLI for ECR login (simpler than credential helper)
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $ECR_HOST
          
          echo "=== Stop old containers ==="
          docker stop backend || true
          docker rm -f backend || true
          docker container prune -f || true
          
          echo "=== Pull new image ==="
          IMAGE="${ECR_REGISTRY}:latest"
          timeout 300 docker pull "$IMAGE" || {
            echo "❌ Docker pull failed or timed out"
            exit 1
          }
          
          echo "=== Run database migration (with timeout) ==="
          timeout 120 docker run --rm --name db-migrate \
            -e ApiConfigs__DBConnection="Host=__DB_HOST__;Port=__DB_PORT__;Database=__DB_NAME__;User Id=__DB_USER__;Password=__DB_PASSWORD__" \
            "$IMAGE" bash -c "cd /app/SettlyModels && dotnet ef database update --startup-project ../SettlyApi" || {
            echo "⚠️ Migration failed or timed out, continuing..."
          }
          
          echo "=== Run database seeding (with timeout) ==="
          timeout 180 docker run --rm --name db-seed \
            -e ApiConfigs__DBConnection="Host=__DB_HOST__;Port=__DB_PORT__;Database=__DB_NAME__;User Id=__DB_USER__;Password=__DB_PASSWORD__" \
            -e ASPNETCORE_ENVIRONMENT=Development \
            "$IMAGE" bash -c "cd /app/SettlyDbManager && dotnet run -- --seed" || {
            echo "⚠️ Seeding failed or timed out, continuing..."
          }
          
          echo "=== Start new container ==="
          docker run -d --name backend --restart unless-stopped -p 5100:5100 \
            -e ASPNETCORE_ENVIRONMENT=Production \
            -e ASPNETCORE_URLS="http://0.0.0.0:5100" \
            -e ApiConfigs__DBConnection="Host=__DB_HOST__;Port=__DB_PORT__;Database=__DB_NAME__;User Id=__DB_USER__;Password=__DB_PASSWORD__" \
            -e JWTConfig__SecretKey="SettlyAISuperSecretKey!@#$%^&*()_+1234567890" \
            -e JWTConfig__Issuer="SettlyAI" \
            -e JWTConfig__Audience="SettlyAI" \
            -e JWTConfig__ExpireSeconds="7200" \
            "$IMAGE" bash -c "cd /app/SettlyApi && dotnet run --urls='http://0.0.0.0:5100'"
          
          echo "=== Wait for container to start ==="
          sleep 15
          
          echo "=== Verify deployment ==="
          docker ps | grep backend || echo "❌ Backend container not running"
          docker logs --tail 20 backend || true
          
          # Quick health check
          timeout 10 docker exec backend curl -f http://localhost:5100/health || echo "⚠️ Health check failed"
          
          echo "=== Deployment completed at $(date) ==="
          EOF

          # Replace placeholders
          sed -i \
            -e "s|__ECR_REGISTRY__|$ECR_REGISTRY|g" \
            -e "s|__AWS_REGION__|$AWS_REGION|g" \
            -e "s|__DB_HOST__|$DB_HOST|g" \
            -e "s|__DB_PORT__|$DB_PORT|g" \
            -e "s|__DB_NAME__|$DB_NAME|g" \
            -e "s|__DB_USER__|$DB_USER|g" \
            -e "s|__DB_PASSWORD__|$DB_PASSWORD|g" \
            /tmp/deploy-backend.sh

          chmod +x /tmp/deploy-backend.sh

      - name: Execute deployment via SSM
        run: |
          set -euo pipefail
          
          # Encode script
          SCRIPT_B64=$(base64 -w0 /tmp/deploy-backend.sh)
          REMOTE_CMD="bash -c 'echo ${SCRIPT_B64} | base64 -d >/tmp/deploy.sh && chmod +x /tmp/deploy.sh && timeout 900 /tmp/deploy.sh'"
          
          # Send command
          CMD_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --region "$AWS_REGION" \
            --instance-ids "$INSTANCE_ID" \
            --comment "Deploy backend with timeout protection" \
            --timeout-seconds 900 \
            --parameters "commands=[\"$REMOTE_CMD\"]" \
            --query "Command.CommandId" --output text)
          
          echo "SSM CommandId: $CMD_ID"
          
          # Wait for completion with shorter timeout
          for i in {1..60}; do
            echo "Check attempt $i/60..."
            
            COMMAND_DETAILS=$(aws ssm get-command-invocation \
              --command-id "$CMD_ID" \
              --instance-id "$INSTANCE_ID" \
              --region "$AWS_REGION" \
              --output json 2>/dev/null || echo '{}')
            
            STATUS=$(echo "$COMMAND_DETAILS" | jq -r '.Status // "Unknown"')
            echo "Status: $STATUS"
            
            case "$STATUS" in
              Success|Failed|Cancelled|TimedOut) 
                echo "=== FINAL OUTPUT ==="
                echo "$COMMAND_DETAILS" | jq -r '.StandardOutputContent // "No output"'
                echo "=== FINAL ERRORS ==="
                echo "$COMMAND_DETAILS" | jq -r '.StandardErrorContent // "No errors"'
                
                if [ "$STATUS" = "Success" ]; then
                  echo "✅ Deployment completed successfully"
                  exit 0
                else
                  echo "❌ Deployment failed with status: $STATUS"
                  exit 1
                fi
                ;;
              InProgress|Pending|Delayed) 
                sleep 15
                ;;
              *) 
                echo "Unknown status, waiting..."
                sleep 10
                ;;
            esac
          done
          
          echo "❌ Deployment timed out after 15 minutes"
          exit 1